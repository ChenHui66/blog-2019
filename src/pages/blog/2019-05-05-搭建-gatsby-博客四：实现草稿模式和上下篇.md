---
layout: blog-post
draft: false
date: 2019-05-05T12:00:02.769Z
title: 搭建 Gatsby 博客四：实现草稿模式和上下篇
description: 前面已经让博客顺利运行起来，接下来就是实现一些个性化的功能。本文通过实现草稿模式和上下篇来了解 Gatsby 的 Node APIs。
quote:
  author: Ernest Hemingway
  content: '"The first draft of anything is shit." '
  source: ''
tags:
  - Gatsby
  - Blog
---
## 草稿模式

草稿模式即可以将文章保存为草稿而不被渲染出来。方式是在 front matters 中设置一个 `draft` 布尔域，以此域作为渲染参考。

### 坑

这里有一个地方需要注意，前面文章提过，Markdown 插件需要所有文章中都有 `draft` 域且都是布尔类型才会生成相应的 GraphQL 查询。如果是新的博客这个问题不大，如果是迁移过来的，有两个解决方式，第一个是手动写个脚本给文章都补上域，另一个是接下要介绍的，利用 Gatsby 的 Node APIs，后者鲁棒性更好些。

### 自动生成域

观察 Remark 插件生成的 GraphQL 类型，我们可以发现，front matters 都被放在 `frontmatter` 域中，而与之同级的有一个 `fields` 域，这个域下一般就是放自定义生成的数据。

Gatsby 在生成 GraphQL 节点时提供了钩子 `onCreateNode`，我们利用这个钩子往 `fields` 中放自定义的数据。

编辑 `/gatsby-node.js`，如果是用了 starter 的话这里很可能已经有其它的代码，已有的不需要动，添加我们需要的即可。

```javascript
exports.onCreateNode = ({ node, actions, getNode }) => {
  const { createNodeField } = actions

  if (node.internal.type === `MarkdownRemark`) {
    createNodeField({
      node,
      name: 'draft',
      value: Boolean(node.frontmatter.draft)
    })
  }
}
```

如此 `fields` 中就保证了会有 `draft` 这个域了。

### 过滤草稿

有了标记之后，在生成页面的地方我们就需要过滤草稿。

首先是普通的文章页面生成，这个是在 `createPages` 钩子中，如果你的博客只有文章用到 Markdown 的话，可以在 GraphQL 查询中直接过滤，否则我们先取所有 Markdown 文件再根据渲染的模板来分别处理各种类型的文章。

如果用了 starter 的话这里应该已经有了生成文章页面的代码，通过 `createPage` 方法关键字定位到生成文章的[地方](https://github.com/crimx/blog-2019/blob/d7c8c6bbbe73ef455f70bc629d153b836482f788/gatsby-node.js#L71-L79)，我们在生成前过滤掉草稿。

注意我把模板域的名字换成了自己更习惯的 `layout`，原来的 starter 中应该叫 `templateKey`。修改其实也很简单，搜索所有文件替换关键字即可。

```javascript
options
  .filter(
    (_, i) =>
      !(
        edges[i].node.frontmatter.layout === 'blog-post' &&
        edges[i].node.fields.draft
      )
  )
  .forEach(option => createPage(option))
```

我在主页中也列举了最近的几篇文章，这里也需要过滤草稿，可以直接在 GraphQL 中过滤。

```graphql
query IndexQuery {
  latestPosts: allMarkdownRemark(
    sort: { order: DESC, fields: [frontmatter___date] }
    filter: {
      fields: { draft: { ne: true } }
      frontmatter: { layout: { eq: "blog-post" } }
    }
    limit: 5
  ) {
    edges {
      node {
        excerpt(pruneLength: 200)
        id
        fields {
          slug
        }
        frontmatter {
          title
          description
          layout
          date(formatString: "MMMM DD, YYYY")
        }
      }
    }
  }
}
```

其它地方同理。

## 上下篇

在文章页面中我们通常会加入上下篇来引导继续浏览。这里我们同样在 `createPages` 钩子中处理，但这回我们添加到 `context` 域中，这个域里的数据会作为 props 传到模板组件中。

在 `createPage` 生成文章页面前[添加处理代码](https://github.com/crimx/blog-2019/blob/d7c8c6bbbe73ef455f70bc629d153b836482f788/gatsby-node.js#L47-L68)计算上下篇：

```javascript
options
  .filter(
    (_, i) =>
      edges[i].node.frontmatter.layout === 'blog-post' &&
      !edges[i].node.fields.draft
  )
  .forEach((option, i, blogPostOptions) => {
    option.context.prev =
      i === 0
        ? null
        : {
          title: blogPostOptions[i - 1].title,
          path: blogPostOptions[i - 1].path
        }
    option.context.next =
      i === blogPostOptions.length - 1
        ? null
        : {
          title: blogPostOptions[i + 1].title,
          path: blogPostOptions[i + 1].path
        }
  })
```

然后在文章的 `/src/templates/blog-post.js` 组件里，接收 `pageContext` props，就可以使用上面传入的数据了。[这是](https://github.com/crimx/blog-2019/blob/1b2f63a60448a502c632d120c798009b2960b19f/src/templates/blog-post.js#L123-L160)我的例子。

通过实现这两个功能基本上可以了解 Gatsby 页面生成的方式了。下篇文章中我会继续谈谈其它更个性化的功能，如改变文章生成的路径以兼容原来的博客系统。
